// ignore_for_file: slash_for_doc_comments, unnecessary_new, non_constant_identifier_names, constant_identifier_names, unnecessary_this, empty_constructor_bodies, annotate_overrides, unnecessary_null_comparison, prefer_collection_literals, no_leading_underscores_for_local_identifiers, unused_import, unnecessary_import, prefer_interpolation_to_compose_strings, camel_case_types, prefer_generic_function_type_aliases, avoid_init_to_null, prefer_final_fields, unused_field

/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library nebula_graph.src.graph_service;

import 'dart:async';
import 'dart:typed_data' show Int8List;
import 'package:fbthrift/fbthrift.dart';
import 'package:nebula_dart_gdbc/gen/nebula_graph/nebula_graph.dart';
import 'package:nebula_dart_gdbc/gen/nebula/nebula.dart' as t_nebula;

abstract class GraphService {
  Future<AuthResponse> authenticate(Int8List username, Int8List password);

  Future signout(int sessionId);

  Future<ExecutionResponse> execute(int sessionId, Int8List stmt);

  Future<ExecutionResponse> executeWithParameter(
      int sessionId, Int8List stmt, Map<Int8List, t_nebula.Value> parameterMap);

  Future<Int8List> executeJson(int sessionId, Int8List stmt);

  Future<Int8List> executeJsonWithParameter(
      int sessionId, Int8List stmt, Map<Int8List, t_nebula.Value> parameterMap);

  Future<VerifyClientVersionResp> verifyClientVersion(
      VerifyClientVersionReq? req);
}

class GraphServiceClient implements GraphService {
  GraphServiceClient(TProtocol iprot, [TProtocol? oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  late TProtocol _iprot;

  TProtocol get iprot => _iprot;

  late TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => _seqid;

  Future<AuthResponse> authenticate(
      Int8List username, Int8List password) async {
    print('authenticate');
    oprot.writeMessageBegin(
        new TMessage("authenticate", TMessageType.CALL, nextSeqid()));
    authenticate_args args = new authenticate_args();
    args.username = username;
    args.password = password;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    authenticate_result result = new authenticate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "authenticate failed: unknown result");
  }

  Future signout(int sessionId) async {
    oprot.writeMessageBegin(
        new TMessage("signout", TMessageType.ONEWAY, nextSeqid()));
    signout_args args = new signout_args();
    args.sessionId = sessionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();
  }

  Future<ExecutionResponse> execute(int sessionId, Int8List stmt) async {
    print('execute');
    oprot.writeMessageBegin(
        new TMessage("execute", TMessageType.CALL, nextSeqid()));
    execute_args args = new execute_args();
    args.sessionId = sessionId;
    args.stmt = stmt;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    execute_result result = new execute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(
        TApplicationErrorType.MISSING_RESULT, "execute failed: unknown result");
  }

  Future<ExecutionResponse> executeWithParameter(int sessionId, Int8List stmt,
      Map<Int8List, t_nebula.Value> parameterMap) async {
    oprot.writeMessageBegin(
        new TMessage("executeWithParameter", TMessageType.CALL, nextSeqid()));
    executeWithParameter_args args = new executeWithParameter_args();
    args.sessionId = sessionId;
    args.stmt = stmt;
    args.parameterMap = parameterMap;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    executeWithParameter_result result = new executeWithParameter_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "executeWithParameter failed: unknown result");
  }

  Future<Int8List> executeJson(int sessionId, Int8List stmt) async {
    oprot.writeMessageBegin(
        new TMessage("executeJson", TMessageType.CALL, nextSeqid()));
    executeJson_args args = new executeJson_args();
    args.sessionId = sessionId;
    args.stmt = stmt;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    executeJson_result result = new executeJson_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "executeJson failed: unknown result");
  }

  Future<Int8List> executeJsonWithParameter(int sessionId, Int8List stmt,
      Map<Int8List, t_nebula.Value> parameterMap) async {
    oprot.writeMessageBegin(new TMessage(
        "executeJsonWithParameter", TMessageType.CALL, nextSeqid()));
    executeJsonWithParameter_args args = new executeJsonWithParameter_args();
    args.sessionId = sessionId;
    args.stmt = stmt;
    args.parameterMap = parameterMap;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    executeJsonWithParameter_result result =
        new executeJsonWithParameter_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "executeJsonWithParameter failed: unknown result");
  }

  Future<VerifyClientVersionResp> verifyClientVersion(
      VerifyClientVersionReq? req) async {
    print('verifyClientVersion');
    oprot.writeMessageBegin(
        new TMessage("verifyClientVersion", TMessageType.CALL, nextSeqid()));
    verifyClientVersion_args args = new verifyClientVersion_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyClientVersion_result result = new verifyClientVersion_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "verifyClientVersion failed: unknown result");
  }
}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class GraphServiceProcessor implements TProcessor {
  GraphServiceProcessor(GraphService iface) {
    iface_ = iface;
    PROCESS_MAP["authenticate"] = authenticate;
    PROCESS_MAP["signout"] = signout;
    PROCESS_MAP["execute"] = execute;
    PROCESS_MAP["executeWithParameter"] = executeWithParameter;
    PROCESS_MAP["executeJson"] = executeJson;
    PROCESS_MAP["executeJsonWithParameter"] = executeJsonWithParameter;
    PROCESS_MAP["verifyClientVersion"] = verifyClientVersion;
  }

  late GraphService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction? fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(
          TApplicationErrorType.UNKNOWN_METHOD,
          "Invalid method name: '" + msg.name + "'");
      oprot.writeMessageBegin(
          new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.trans_.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  authenticate(int seqid, TProtocol iprot, TProtocol oprot) async {
    authenticate_args args = new authenticate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    authenticate_result result = new authenticate_result();
    result.success = await iface_.authenticate(
        args.username ?? Int8List(0), args.password ?? Int8List(0));
    oprot.writeMessageBegin(
        new TMessage("authenticate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  signout(int seqid, TProtocol iprot, TProtocol oprot) {
    signout_args args = new signout_args();
    args.read(iprot);
    iprot.readMessageEnd();
    iface_.signout(args.sessionId);
    return;
  }

  execute(int seqid, TProtocol iprot, TProtocol oprot) async {
    execute_args args = new execute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    execute_result result = new execute_result();
    result.success =
        await iface_.execute(args.sessionId, args.stmt ?? Int8List(0));
    oprot.writeMessageBegin(new TMessage("execute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  executeWithParameter(int seqid, TProtocol iprot, TProtocol oprot) async {
    executeWithParameter_args args = new executeWithParameter_args();
    args.read(iprot);
    iprot.readMessageEnd();
    executeWithParameter_result result = new executeWithParameter_result();
    result.success = await iface_.executeWithParameter(
        args.sessionId, args.stmt ?? Int8List(0), args.parameterMap ?? {});
    oprot.writeMessageBegin(
        new TMessage("executeWithParameter", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  executeJson(int seqid, TProtocol iprot, TProtocol oprot) async {
    executeJson_args args = new executeJson_args();
    args.read(iprot);
    iprot.readMessageEnd();
    executeJson_result result = new executeJson_result();
    result.success =
        await iface_.executeJson(args.sessionId, args.stmt ?? Int8List(0));
    oprot.writeMessageBegin(
        new TMessage("executeJson", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  executeJsonWithParameter(int seqid, TProtocol iprot, TProtocol oprot) async {
    executeJsonWithParameter_args args = new executeJsonWithParameter_args();
    args.read(iprot);
    iprot.readMessageEnd();
    executeJsonWithParameter_result result =
        new executeJsonWithParameter_result();
    result.success = await iface_.executeJsonWithParameter(
        args.sessionId, args.stmt ?? Int8List(0), args.parameterMap ?? {});
    oprot.writeMessageBegin(
        new TMessage("executeJsonWithParameter", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  verifyClientVersion(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyClientVersion_args args = new verifyClientVersion_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyClientVersion_result result = new verifyClientVersion_result();
    result.success = await iface_.verifyClientVersion(args.req);
    oprot.writeMessageBegin(
        new TMessage("verifyClientVersion", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }
}

class authenticate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("authenticate_args");
  static final TField _USERNAME_FIELD_DESC =
      new TField("username", TType.STRING, 1);
  static final TField _PASSWORD_FIELD_DESC =
      new TField("password", TType.STRING, 2);

  Int8List? _username;
  static const int USERNAME = 1;
  Int8List? _password;
  static const int PASSWORD = 2;

  authenticate_args() {}

  // username
  Int8List? get username => this._username;

  set username(Int8List? username) {
    this._username = username;
  }

  bool isSetUsername() => this.username != null;

  unsetUsername() {
    this.username = null;
  }

  // password
  Int8List? get password => this._password;

  set password(Int8List? password) {
    this._password = password;
  }

  bool isSetPassword() => this.password != null;

  unsetPassword() {
    this.password = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USERNAME:
        return this.username;
      case PASSWORD:
        return this.password;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USERNAME:
        if (value == null) {
          unsetUsername();
        } else {
          this.username = value as Int8List?;
        }
        break;

      case PASSWORD:
        if (value == null) {
          unsetPassword();
        } else {
          this.password = value as Int8List?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USERNAME:
        return isSetUsername();
      case PASSWORD:
        return isSetPassword();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USERNAME:
          if (field.type == TType.STRING) {
            this.username = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWORD:
          if (field.type == TType.STRING) {
            this.password = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.username != null) {
      oprot.writeFieldBegin(_USERNAME_FIELD_DESC);
      oprot.writeBinary(this.username);
      oprot.writeFieldEnd();
    }
    if (this.password != null) {
      oprot.writeFieldBegin(_PASSWORD_FIELD_DESC);
      oprot.writeBinary(this.password);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("authenticate_args(");

    ret.write("username:");
    if (this.username == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(", ");
    ret.write("password:");
    if (this.password == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class authenticate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("authenticate_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  AuthResponse? _success;
  static const int SUCCESS = 0;

  authenticate_result() {}

  // success
  AuthResponse? get success => this._success;

  set success(AuthResponse? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as AuthResponse?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthResponse();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("authenticate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class signout_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("signout_args");
  static final TField _SESSION_ID_FIELD_DESC =
      new TField("sessionId", TType.I64, 1);

  int _sessionId = 0;
  static const int SESSIONID = 1;

  bool __isset_sessionId = false;

  signout_args() {}

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value as int;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.I64) {
            this.sessionId = iprot.readI64();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeI64(this.sessionId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("signout_args(");

    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class execute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("execute_args");
  static final TField _SESSION_ID_FIELD_DESC =
      new TField("sessionId", TType.I64, 1);
  static final TField _STMT_FIELD_DESC = new TField("stmt", TType.STRING, 2);

  int _sessionId = 0;
  static const int SESSIONID = 1;
  Int8List? _stmt;
  static const int STMT = 2;

  bool __isset_sessionId = false;

  execute_args() {}

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  // stmt
  Int8List? get stmt => this._stmt;

  set stmt(Int8List? stmt) {
    this._stmt = stmt;
  }

  bool isSetStmt() => this.stmt != null;

  unsetStmt() {
    this.stmt = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case STMT:
        return this.stmt;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value as int;
        }
        break;

      case STMT:
        if (value == null) {
          unsetStmt();
        } else {
          this.stmt = value as Int8List?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case STMT:
        return isSetStmt();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.I64) {
            this.sessionId = iprot.readI64();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STMT:
          if (field.type == TType.STRING) {
            this.stmt = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeI64(this.sessionId);
    oprot.writeFieldEnd();
    if (this.stmt != null) {
      oprot.writeFieldBegin(_STMT_FIELD_DESC);
      oprot.writeBinary(this.stmt);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("execute_args(");

    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(", ");
    ret.write("stmt:");
    if (this.stmt == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class execute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("execute_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecutionResponse? _success;
  static const int SUCCESS = 0;

  execute_result() {}

  // success
  ExecutionResponse? get success => this._success;

  set success(ExecutionResponse? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecutionResponse?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecutionResponse();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("execute_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeWithParameter_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("executeWithParameter_args");
  static final TField _SESSION_ID_FIELD_DESC =
      new TField("sessionId", TType.I64, 1);
  static final TField _STMT_FIELD_DESC = new TField("stmt", TType.STRING, 2);
  static final TField _PARAMETER_MAP_FIELD_DESC =
      new TField("parameterMap", TType.MAP, 3);

  int _sessionId = 0;
  static const int SESSIONID = 1;
  Int8List? _stmt;
  static const int STMT = 2;
  Map<Int8List, t_nebula.Value>? _parameterMap;
  static const int PARAMETERMAP = 3;

  bool __isset_sessionId = false;

  executeWithParameter_args() {}

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  // stmt
  Int8List? get stmt => this._stmt;

  set stmt(Int8List? stmt) {
    this._stmt = stmt;
  }

  bool isSetStmt() => this.stmt != null;

  unsetStmt() {
    this.stmt = null;
  }

  // parameterMap
  Map<Int8List, t_nebula.Value>? get parameterMap => this._parameterMap;

  set parameterMap(Map<Int8List, t_nebula.Value>? parameterMap) {
    this._parameterMap = parameterMap;
  }

  bool isSetParameterMap() => this.parameterMap != null;

  unsetParameterMap() {
    this.parameterMap = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case STMT:
        return this.stmt;
      case PARAMETERMAP:
        return this.parameterMap;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value as int;
        }
        break;

      case STMT:
        if (value == null) {
          unsetStmt();
        } else {
          this.stmt = value as Int8List?;
        }
        break;

      case PARAMETERMAP:
        if (value == null) {
          unsetParameterMap();
        } else {
          this.parameterMap = value as Map<Int8List, t_nebula.Value>?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case STMT:
        return isSetStmt();
      case PARAMETERMAP:
        return isSetParameterMap();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.I64) {
            this.sessionId = iprot.readI64();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STMT:
          if (field.type == TType.STRING) {
            this.stmt = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAMETERMAP:
          if (field.type == TType.MAP) {
            {
              TMap _map28 = iprot.readMapBegin();
              this.parameterMap = new Map<Int8List, t_nebula.Value>();
              for (int _i29 = 0; _i29 < _map28.length; ++_i29) {
                Int8List _key30;
                t_nebula.Value _val31;
                _key30 = iprot.readBinary();
                _val31 = new t_nebula.Value();
                _val31.read(iprot);
                this.parameterMap?[_key30] = _val31;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeI64(this.sessionId);
    oprot.writeFieldEnd();
    if (this.stmt != null) {
      oprot.writeFieldBegin(_STMT_FIELD_DESC);
      oprot.writeBinary(this.stmt);
      oprot.writeFieldEnd();
    }
    if (this.parameterMap != null) {
      oprot.writeFieldBegin(_PARAMETER_MAP_FIELD_DESC);
      {
        oprot.writeMapBegin(
            new TMap(TType.STRING, TType.STRUCT, this.parameterMap?.length));
        for (var elem33 in this.parameterMap?.keys ?? <Int8List>[]) {
          oprot.writeBinary(elem33);
          this.parameterMap?[elem33]?.write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeWithParameter_args(");

    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(", ");
    ret.write("stmt:");
    if (this.stmt == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(", ");
    ret.write("parameterMap:");
    if (this.parameterMap == null) {
      ret.write("null");
    } else {
      ret.write(this.parameterMap);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeWithParameter_result implements TBase {
  static final TStruct _STRUCT_DESC =
      new TStruct("executeWithParameter_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecutionResponse? _success;
  static const int SUCCESS = 0;

  executeWithParameter_result() {}

  // success
  ExecutionResponse? get success => this._success;

  set success(ExecutionResponse? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecutionResponse;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecutionResponse();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeWithParameter_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeJson_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("executeJson_args");
  static final TField _SESSION_ID_FIELD_DESC =
      new TField("sessionId", TType.I64, 1);
  static final TField _STMT_FIELD_DESC = new TField("stmt", TType.STRING, 2);

  int _sessionId = 0;
  static const int SESSIONID = 1;
  Int8List? _stmt;
  static const int STMT = 2;

  bool __isset_sessionId = false;

  executeJson_args() {}

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  // stmt
  Int8List? get stmt => this._stmt;

  set stmt(Int8List? stmt) {
    this._stmt = stmt;
  }

  bool isSetStmt() => this.stmt != null;

  unsetStmt() {
    this.stmt = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case STMT:
        return this.stmt;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value as int;
        }
        break;

      case STMT:
        if (value == null) {
          unsetStmt();
        } else {
          this.stmt = value as Int8List;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case STMT:
        return isSetStmt();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.I64) {
            this.sessionId = iprot.readI64();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STMT:
          if (field.type == TType.STRING) {
            this.stmt = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeI64(this.sessionId);
    oprot.writeFieldEnd();
    if (this.stmt != null) {
      oprot.writeFieldBegin(_STMT_FIELD_DESC);
      oprot.writeBinary(this.stmt);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeJson_args(");

    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(", ");
    ret.write("stmt:");
    if (this.stmt == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeJson_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("executeJson_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRING, 0);

  Int8List? _success;
  static const int SUCCESS = 0;

  executeJson_result() {}

  // success
  Int8List? get success => this._success;

  set success(Int8List? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Int8List;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeJson_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeJsonWithParameter_args implements TBase {
  static final TStruct _STRUCT_DESC =
      new TStruct("executeJsonWithParameter_args");
  static final TField _SESSION_ID_FIELD_DESC =
      new TField("sessionId", TType.I64, 1);
  static final TField _STMT_FIELD_DESC = new TField("stmt", TType.STRING, 2);
  static final TField _PARAMETER_MAP_FIELD_DESC =
      new TField("parameterMap", TType.MAP, 3);

  int _sessionId = 0;
  static const int SESSIONID = 1;
  Int8List? _stmt;
  static const int STMT = 2;
  Map<Int8List, t_nebula.Value>? _parameterMap;
  static const int PARAMETERMAP = 3;

  bool __isset_sessionId = false;

  executeJsonWithParameter_args() {}

  // sessionId
  int get sessionId => this._sessionId;

  set sessionId(int sessionId) {
    this._sessionId = sessionId;
    this.__isset_sessionId = true;
  }

  bool isSetSessionId() => this.__isset_sessionId;

  unsetSessionId() {
    this.__isset_sessionId = false;
  }

  // stmt
  Int8List? get stmt => this._stmt;

  set stmt(Int8List? stmt) {
    this._stmt = stmt;
  }

  bool isSetStmt() => this.stmt != null;

  unsetStmt() {
    this.stmt = null;
  }

  // parameterMap
  Map<Int8List, t_nebula.Value>? get parameterMap => this._parameterMap;

  set parameterMap(Map<Int8List, t_nebula.Value>? parameterMap) {
    this._parameterMap = parameterMap;
  }

  bool isSetParameterMap() => this.parameterMap != null;

  unsetParameterMap() {
    this.parameterMap = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return this.sessionId;
      case STMT:
        return this.stmt;
      case PARAMETERMAP:
        return this.parameterMap;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSIONID:
        if (value == null) {
          unsetSessionId();
        } else {
          this.sessionId = value as int;
        }
        break;

      case STMT:
        if (value == null) {
          unsetStmt();
        } else {
          this.stmt = value as Int8List;
        }
        break;

      case PARAMETERMAP:
        if (value == null) {
          unsetParameterMap();
        } else {
          this.parameterMap = value as Map<Int8List, t_nebula.Value>;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSIONID:
        return isSetSessionId();
      case STMT:
        return isSetStmt();
      case PARAMETERMAP:
        return isSetParameterMap();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSIONID:
          if (field.type == TType.I64) {
            this.sessionId = iprot.readI64();
            this.__isset_sessionId = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STMT:
          if (field.type == TType.STRING) {
            this.stmt = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAMETERMAP:
          if (field.type == TType.MAP) {
            {
              TMap _map34 = iprot.readMapBegin();
              this.parameterMap = new Map<Int8List, t_nebula.Value>();
              for (int _i35 = 0; _i35 < _map34.length; ++_i35) {
                Int8List _key36;
                t_nebula.Value _val37;
                _key36 = iprot.readBinary();
                _val37 = new t_nebula.Value();
                _val37.read(iprot);
                this.parameterMap?[_key36] = _val37;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SESSION_ID_FIELD_DESC);
    oprot.writeI64(this.sessionId);
    oprot.writeFieldEnd();
    if (this.stmt != null) {
      oprot.writeFieldBegin(_STMT_FIELD_DESC);
      oprot.writeBinary(this.stmt);
      oprot.writeFieldEnd();
    }
    if (this.parameterMap != null) {
      oprot.writeFieldBegin(_PARAMETER_MAP_FIELD_DESC);
      {
        oprot.writeMapBegin(
            new TMap(TType.STRING, TType.STRUCT, this.parameterMap?.length));
        for (var elem39 in this.parameterMap?.keys ?? <Int8List>[]) {
          oprot.writeBinary(elem39);
          this.parameterMap?[elem39]?.write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeJsonWithParameter_args(");

    ret.write("sessionId:");
    ret.write(this.sessionId);

    ret.write(", ");
    ret.write("stmt:");
    if (this.stmt == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(", ");
    ret.write("parameterMap:");
    if (this.parameterMap == null) {
      ret.write("null");
    } else {
      ret.write(this.parameterMap);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class executeJsonWithParameter_result implements TBase {
  static final TStruct _STRUCT_DESC =
      new TStruct("executeJsonWithParameter_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRING, 0);

  Int8List? _success;
  static const int SUCCESS = 0;

  executeJsonWithParameter_result() {}

  // success
  Int8List? get success => this._success;

  set success(Int8List? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as Int8List?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("executeJsonWithParameter_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class verifyClientVersion_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyClientVersion_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  VerifyClientVersionReq? _req;
  static const int REQ = 1;

  verifyClientVersion_args() {}

  // req
  VerifyClientVersionReq? get req => this._req;

  set req(VerifyClientVersionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as VerifyClientVersionReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new VerifyClientVersionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyClientVersion_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class verifyClientVersion_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyClientVersion_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  VerifyClientVersionResp? _success;
  static const int SUCCESS = 0;

  verifyClientVersion_result() {}

  // success
  VerifyClientVersionResp? get success => this._success;

  set success(VerifyClientVersionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as VerifyClientVersionResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new VerifyClientVersionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyClientVersion_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
